/*============================================================================*\
 | Copyright (C) 2015 Matthew Edwards                                         |
 |                                                                            |
 | Licensed under the Apache License, Version 2.0 (the "License"); you may    |
 | not use this file except in compliance with the License. You may obtain a  |
 | copy of the License at                                                     |
 |                                                                            |
 |     http://www.apache.org/licenses/LICENSE-2.0                             |
 |                                                                            |
 | Unless required by applicable law or agreed to in writing, software        |
 | distributed under the License is distributed on an "AS IS" BASIS,          |
 | WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   |
 | See the License for the specific language governing permissions and        |
 | limitations under the License.                                             |
\*============================================================================*/

package me.edwards.des;

import java.io.IOException;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.security.Signature;
import java.security.interfaces.ECPublicKey;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import me.edwards.des.block.Ballot;
import me.edwards.des.block.Block;
import me.edwards.des.block.BlockChain;
import me.edwards.des.demo.Submitter;
import me.edwards.des.net.Connection;
import me.edwards.des.net.packet.Packet;
import me.edwards.des.net.packet.Packet.PacketTypes;
import me.edwards.des.net.packet.PacketAddr;
import me.edwards.des.net.packet.PacketBallot;
import me.edwards.des.net.packet.PacketBlock;
import me.edwards.des.net.packet.PacketGetAddr;
import me.edwards.des.net.packet.PacketGetBlocks;
import me.edwards.des.net.packet.PacketGetData;
import me.edwards.des.net.packet.PacketInv;
import me.edwards.des.net.packet.PacketNotFound;
import me.edwards.des.net.packet.PacketPing;
import me.edwards.des.net.packet.PacketPong;
import me.edwards.des.net.packet.PacketVerack;
import me.edwards.des.net.packet.PacketVersion;
import me.edwards.des.util.ByteUtil;
import me.edwards.des.util.Version;

// -----------------------------------------------------------------------------
/**
 * A Miner Node is the most complex autonomous unit that operates on the DES
 * Network. This class handles all of the higher-level processes for a Miner
 * Node, including processing of packets received by the Node, generation of new
 * Blocks, handling of broadcasted Ballots, and validation of data generated by
 * other Nodes. <br>
 * <br>
 * When this Node is placed on a network with additional Nodes running the same
 * software, they are able to "mine" ballots broadcast by Election Applications
 * using the Decentralized Election System. This is the step in the process that
 * ensures the validity of each individual's vote and causes them to be
 * immutably and permanently inserted into the public
 * {@link me.edwards.des.block.BlockChain BlockChain}, preventing corruption in
 * a democratic voting system.<br>
 * <br>
 * Created on: Oct 16, 2015 at 9:35:54 PM
 * 
 * @author Matthew Edwards
 */
public class Node
{
    // ~ Static/Instance variables .............................................

    // -------------------------------------------------------------------------
    /**
     * Node's software version. Used in version authentication during the
     * handshake process.
     */
    public static final Version     VERSION         = new Version(
                                                        "15.12.31.1 DES_ALPHA");

    /**
     * Default Packet Buffer Size
     */
    public static final int         BUFFER_SIZE     = 8192;

    /**
     * Threshold number of Ballots required to begin mining a Block. This number
     * is also the maximum number of Ballots allowed in a Block, configurable to
     * each indiviual Node.
     */
    public static final int         BLOCK_THRESHOLD = 500;

    /**
     * Minimum amount of time (in seconds) to begin mining a Block
     */
    public static final int         BLOCK_TIME      = 60 * 5;

    // -------------------------------------------------------------------------
    /**
     * Logger instance to be used by this Node. Initialized during launching
     * process.
     */
    protected Logger                logger;

    /**
     * List of initial peers to be contacted during the bootstrapping process.
     */
    protected ArrayList<String>     peerList;

    /**
     * This Node's private version of the BlockChain. Used for Block validation
     * and storage.
     */
    protected BlockChain            blockChain;

    /**
     * Hash of the parent of the Block currently being generated by the Node.
     */
    protected String                blockGenHash;

    /**
     * List of connections containing all of this Node's current peers.
     */
    protected ArrayList<Connection> peers;

    /**
     * This Node's private list of all known, unmined ballots. Ballots inserted
     * into new Blocks are copied from this list as new Blocks are generated.
     */
    protected ArrayList<Ballot>     ballots;

    /**
     * This Node's IP Address as an InetAddress instance.
     */
    protected InetAddress           ip;

    /**
     * This Node's current listening socket as a ServerSocket instance.
     */
    protected ServerSocket          socket;

    /**
     * This Node's current listening socket port. Used for manual connections.
     */
    protected int                   port;

    /**
     * This Node's human readable name.
     */
    protected String                name;
    
    /**
     * Demonstration mode flag used to indicate if this Node is currently in
     * demonstration mode. This will disable and change some functionality.
     */
    protected boolean               demo;

    /**
     * Running flag used to indicate if this Node is presently accepting and
     * sending packets over connections on the network. True if this Node is
     * 'on' (able to communicate with other Nodes), False if this Node is 'off'
     * (unable to communicate with other Nodes).
     */
    protected boolean               running;

    // -------------------------------------------------------------------------
    /**
     * A list of the hashes of all the data objects requested by this Node. This
     * prevents unsolicited data from being accepted by the Node.
     */
    private ArrayList<String>       dataRequests;
    
    /**
     * This thread accepts handshakes from new, previously unknown peers on the
     * network.
     */
    private Thread                  handshake;
    
    /**
     * This thread initiates Block generation if the {@link Node#BLOCK_TIME
     * time} threshold has been reached.
     */
    private Thread                  blockGenTimer;

    /**
     * This thread is used to attempt generation of new Blocks (mine a proof of
     * work for a new Block). As this process is very time and processor
     * intensive, only one Block can be generated at any given time. This thread
     * is interrupted if a Block is received and has the same parent as the
     * Block currently being generated.
     */
    private Thread                  blockGen    = null;


    // ~ Methods ...............................................................

    // -------------------------------------------------------------------------
    /**
     * Initializes the Node's networking processes and threads, starting the
     * Node on a specific IP Address and Port (specified by the
     * {@link me.edwards.des.Launcher Launcher}). This method creates and starts
     * the {@link Node#handshake Handshake Thread}, allowing other Nodes to
     * connect to this Node. This method will also go through the "Peer List"
     * and attempt to connect to any initial peers, allowing the bootstrapping
     * process to take place. After this method is completed, the
     * {@link Node#running running} flag should be set to True.
     */
    public void start()
    {
        peers = new ArrayList<Connection>();
        ballots = new ArrayList<Ballot>();
        dataRequests = new ArrayList<String>();

        try
        {
            socket = new ServerSocket(port);
            socket.setReceiveBufferSize(BUFFER_SIZE);
            
            ip = InetAddress.getLocalHost();
            port = socket.getLocalPort();
            if (name == null)
            {
                name = ip.getHostAddress() + ":" + port;
            }
            logger.info("Starting Node on /" + ip.getHostAddress() + ":" + port
                + " ...");
        }
        catch (Exception e)
        {
            logger.log(Level.SEVERE, "Could not bind socket!", e);
            return;
        }

        running = true;

        final Node n = this;
        handshake = new Thread(new Runnable() {
            @Override
            public void run()
            {
                while (running)
                {
                    try
                    {
                        Connection c = new Connection(n, socket.accept());
                        logger.info("Accepted connection from Node "
                            + c.getHostName() + "!");
                        c.setConnectionStatus(Connection.CONNECTION_PEER_ONLY);
                        peers.add(c);
                        c.connect();
                    }
                    catch (IOException e)
                    {
                        if (running)
                        {
                            logger.log(
                                Level.WARNING,
                                "Could not accept Node to socket",
                                e);
                        }
                    }
                }
            }
        }, "Node Handshake");
        handshake.start();
        
        blockGenTimer = new Thread(new Runnable() {
            @Override
            public void run()
            {
                while (running)
                {
                    generateBlock();
                    try
                    {
                        Thread.sleep(BLOCK_TIME * 1000);
                    }
                    catch (InterruptedException e)
                    {
                        //
                    }
                }
            }
        }, "Node Block Generation Timer");
        blockGenTimer.start();

        logger.info("Node started!");

        logger.info("Connecting to known peers...");

        for (String peer : peerList)
        {
            try
            {
                connect(
                    InetAddress.getByName(peer.split(":")[0]),
                    Integer.parseInt(peer.split(":")[1]));
            }
            catch (Exception e)
            {
                //
            }
        }

        logger.info("Connected to " + peers.size() + " known peers!");
    }


    // -------------------------------------------------------------------------
    /**
     * Stops the Node's running processes, including the {@link Node#handshake
     * Handshake Thread} (preventing other Nodes from connecting to this Node)
     * and the {@link Node#blockGen Block Generation Thread} (stopping the
     * generation of any new Blocks or Blocks currently being generated). This
     * method also closes all networking sockets currently open. After this
     * method is completed, the {@link Node#running running} flag should be set
     * to False.
     */
    public void stop()
    {
        if (running)
        {
            logger.info("Stopping Node...");
            running = false;

            stopBlockGeneration();
            if (socket != null)
            {
                try
                {
                    socket.close();
                }
                catch (IOException e)
                {
                    //
                }
                socket = null;
            }
            if (handshake != null)
            {
                handshake.interrupt();
                handshake = null;
            }
            if (blockGenTimer != null)
            {
                blockGenTimer.interrupt();
                blockGenTimer = null;
            }
            logger.info("Node stopped!");
        }
    }


    // -------------------------------------------------------------------------
    /**
     * Parses a packet received by a {@link Connection connection} to this Node
     * into a {@link PacketTypes Packet Type} and processes the received data in
     * the packet.<br>
     * <br>
     * <table>
     * <thead>
     * <td><strong>Packet Type</strong></td>
     * <td><strong>Process Category</strong></td>
     * <td><strong>Description of Process</strong></td>
     * </thead>
     * <tr>
     * <td>{@link PacketPing Ping}</td>
     * <td>Connection Status</td>
     * <td>Sends a {@link PacketPong Pong} response to the Ping sender,
     * incrementing the payload by one.</td>
     * </tr>
     * <tr>
     * <td>{@link PacketPong Pong}</td>
     * <td>Connection Status</td>
     * <td>Notifies the corresponding {@link Connection connection} that a
     * response has been received from the peer Node.</td>
     * </tr>
     * <tr>
     * <td>{@link PacketVersion Version}</td>
     * <td>Handshake</td>
     * <td>{@link Node#validateVersion(Version) Validates} the version of the
     * sender Node and sends a {@link PacketVerack VerAck}. Updates the
     * {@link Connection#getConnectionStatus() connection status} and requests
     * Ballot, Block, and Address Cache data from the sender Node. Reception
     * completes the Handshake for the Node requesting the connection initially.
     * </td>
     * </tr>
     * <tr>
     * <td>{@link PacketVerack VerAck}</td>
     * <td>Handshake</td>
     * <td>Updates the {@link Connection#getConnectionStatus() connection
     * status} and requests Ballot, Block, and Address Cache data from the
     * sender Node. Reception completes the Handshake for the Node that did not
     * request the connection initially.</td>
     * </tr>
     * <tr>
     * <td>{@link PacketGetAddr GetAddr}</td>
     * <td>Bootstrapping</td>
     * <td>Sends the requesting Node a copy of all of this Node's current peers.
     * </td>
     * </tr>
     * <tr>
     * <td>{@link PacketAddr Addr}</td>
     * <td>Bootstrapping</td>
     * <td>Parses address cache information and attempts to connect to
     * previously unknown peers.</td>
     * </tr>
     * <tr>
     * <td>{@link PacketInv Inv}</td>
     * <td>Inventory Transfer</td>
     * <td>Sends requests using a {@link PacketGetData GetData packet} to the
     * advertising Node for data objects that this Node does not possess.</td>
     * </tr>
     * <tr>
     * <td>{@link PacketNotFound NotFound}</td>
     * <td>Inventory Transfer</td>
     * <td>Notifies the Node that a requested resources was not found.</td>
     * </tr>
     * <tr>
     * <td>{@link PacketGetData GetData}</td>
     * <td>Inventory Transfer</td>
     * <td>Sends requested data objects to the requesting Node using
     * {@link PacketBallot Ballot data packets} or {@link PacketBlock Block data
     * packets}.</td>
     * </tr>
     * <tr>
     * <td>{@link PacketBallot Ballot}</td>
     * <td>Inventory Transfer</td>
     * <td>Validates {@link Ballot Ballot} and adds it to this Node's list of
     * known Ballots. If this Ballot was not requested, or is invalid, it is
     * discarded. A valid Ballot is propagated to all known peer Nodes with
     * {@link PacketInv Inventory Packets}.</td>
     * </tr>
     * <tr>
     * <td>{@link PacketBlock Block}</td>
     * <td>Inventory Transfer</td>
     * <td>Validates {@link Block Block} and adds it to this Node's
     * {@link BlockChain BlockChain}. If this Block was not requested, or is
     * invalid, it is discarded. A valid Ballot is propagated to all known peer
     * Nodes with {@link PacketInv Inventory Packets}.</td>
     * </tr>
     * <tr>
     * <td>{@link PacketGetBlocks GetBlocks}</td>
     * <td>Inventory Transfer</td>
     * <td>Sends {@link PacketInv Inventory packet} containing all {@link Block
     * Blocks} after the Block specified in the GetBlocks request.</td>
     * </tr>
     * </table>
     * 
     * @see Packet
     * @see PacketAddr
     * @see PacketBallot
     * @see PacketBlock
     * @see PacketGetAddr
     * @see PacketGetBlocks
     * @see PacketGetData
     * @see PacketInv
     * @see PacketNotFound
     * @see PacketPing
     * @see PacketPong
     * @see PacketVerack
     * @see PacketVersion
     * @see Connection
     * @param data
     *            Packet data received by the connection as a byte array.
     * @param connection
     *            Connection object through which the packet was received.
     */
    public void parse(byte[] data, Connection connection)
    {
        logger.finest("Received 0x" + Packet.toHex(data[0]) + " packet from "
            + (connection == null ? "LOCAL" : connection.getHostName()));
        switch (Packet.lookup(data[0]))
        {
            case PING:
            {
                PacketPing packet = new PacketPing(data);
                connection.send(new PacketPong(packet.getPing() + 1));
                return;
            }
            case PONG:
            {
                PacketPong packet = new PacketPong(data);
                if (packet.getPing() - 1 == 0)
                {
                    logger.info("Received PONG from " + connection);
                }
                connection.pong(packet.getPing());
                return;
            }
            case VERSION:
            {
                PacketVersion packet = new PacketVersion(data);
                logger.finer("Received Version from "
                    + connection.getHostName() + "! Validating...");
                if (connection.getConnectionStatus() == Connection.CONNECTION_NODE_ONLY
                    && validateVersion(packet.getVersion()))
                {
                    logger
                        .finer("Version valid! Sending verack and completing handshake...");
                    connection.send(new PacketVerack());
                    connection.setConnectionStatus(Connection.CONNECTION_BOTH);
                    logger.finer("Requesting block information from "
                        + connection);
                    connection.send(new PacketGetBlocks(blockChain.getTop()
                        .getHash()));
                    logger.finer("Sending ballot information to " + connection);
                    PacketInv inv = new PacketInv();
                    for (int i = 0; ballots.size() > i; i++)
                    {
                        inv.addInv(ballots.get(i));
                    }
                    connection.send(inv);
                    logger.finer("Requesting address cache information from "
                        + connection);
                    connection.send(new PacketGetAddr());
                }
                else if (connection.getConnectionStatus() == Connection.CONNECTION_PEER_ONLY
                    && validateVersion(packet.getVersion()))
                {
                    logger
                        .finer("Version valid! Sending version information...");
                    connection.setPort(packet.getPort());
                    connection.send(new PacketVersion(VERSION, port));
                }
                else
                {
                    logger
                        .finer("Could not validate version! Aborting connection...");
                    removeConnection(connection);
                }
                return;
            }
            case VERACK:
            {
                if (connection.getConnectionStatus() != Connection.CONNECTION_BOTH)
                {
                    logger.finer("Received verack! Completing handshake...");
                    connection.setConnectionStatus(Connection.CONNECTION_BOTH);
                    logger.finer("Requesting block information from "
                        + connection);
                    connection.send(new PacketGetBlocks(blockChain.getTop()
                        .getHash()));
                    logger.finer("Sending ballot information to " + connection);
                    PacketInv inv = new PacketInv();
                    for (int i = 0; ballots.size() > i; i++)
                    {
                        inv.addInv(ballots.get(i));
                    }
                    connection.send(inv);
                    logger.finer("Requesting address cache information from "
                        + connection);
                    connection.send(new PacketGetAddr());
                }
                return;
            }
            case GETADDR:
            {
                logger.finer("Request for address cache information from "
                    + connection);
                connection.send(new PacketAddr(this.getPeers()));
                return;
            }
            case ADDR:
            {
                PacketAddr packet = new PacketAddr(data);
                logger.info("Received address cache information from "
                    + connection + ". Bootstrapping...");
                for (String s : packet.getPeers())
                {
                    try
                    {
                        logger.log(Level.FINE, "Connecting to " + s);
                        connect(InetAddress.getByName(s.substring(
                            1,
                            s.indexOf(':'))), Integer.parseInt(s.substring(s
                            .indexOf(':') + 1)));
                    }
                    catch (Exception e)
                    {
                        logger.log(Level.FINE, "Could not connect!", e);
                    }
                }
                return;
            }
            case INV:
            {
                PacketInv packet = new PacketInv(data);
                PacketGetData getData = new PacketGetData();
                for (int i = 0; packet.getSize() > i; i++)
                {
                    if (packet.getType(i) == PacketInv.VECTOR_BALLOT)
                    {
                        if (dataRequests.contains(packet.getHash(i)))
                        {
                            continue;
                        }
                        boolean b = true;
                        for (int v = 0; ballots.size() > v; v++)
                        {
                            if (ballots.get(v).getRoot()
                                .equals(packet.getHash(i)))
                            {
                                b = false;
                                break;
                            }
                        }
                        if (b)
                        {
                            logger.finer("New resource " + packet.getHash(i)
                                + "(" + packet.getType(i)
                                + ")! Requesting data...");
                            dataRequests.add(packet.getHash(i));
                            getData
                                .addInv(packet.getType(i), packet.getHash(i));
                        }
                    }
                    else if (packet.getType(i) == PacketInv.VECTOR_BLOCK)
                    {
                        if (dataRequests.contains(packet.getHash(i)))
                        {
                            continue;
                        }
                        if (!blockChain.contains(packet.getHash(i)))
                        {
                            logger.finer("New resource " + packet.getHash(i)
                                + "(" + packet.getType(i)
                                + ")! Requesting data...");
                            dataRequests.add(packet.getHash(i));
                            getData
                                .addInv(packet.getType(i), packet.getHash(i));
                        }
                    }
                }
                if (getData.getSize() > 0)
                {
                    connection.send(getData);
                }
                return;
            }
            case NOTFOUND:
            {
                PacketNotFound packet = new PacketNotFound(data);
                logger.finer("Received notice that resource "
                    + packet.getHash() + "(" + packet.getType()
                    + ") could not be found.");
                return;
            }
            case GETDATA:
            {
                PacketGetData packet = new PacketGetData(data);
                for (int i = 0; packet.getSize() > i; i++)
                {
                    if (packet.getType(i) == PacketInv.VECTOR_BALLOT)
                    {
                        boolean b = false;
                        for (int v = 0; ballots.size() > v; v++)
                        {
                            if (ballots.get(v).getRoot()
                                .equalsIgnoreCase(packet.getHash(i)))
                            {
                                b = true;
                                logger.finer("Request for resource "
                                    + packet.getHash(i) + "("
                                    + packet.getType(i) + ")! Sending data...");
                                connection
                                    .send(new PacketBallot(ballots.get(v)));
                                break;
                            }
                        }
                        if (!b)
                        {
                            logger.finer("Request for resource "
                                + packet.getHash(i) + "(" + packet.getType(i)
                                + ")! Could not be found! Sending reply...");
                            connection.send(new PacketNotFound(packet
                                .getType(i), packet.getHash(i)));
                        }
                    }
                    else if (packet.getType(i) == PacketInv.VECTOR_BLOCK)
                    {
                        if (blockChain.contains(packet.getHash(i)))
                        {
                            logger.finer("Request for resource "
                                + packet.getHash(i) + "(" + packet.getType(i)
                                + ")! Sending data...");
                            connection.send(new PacketBlock(blockChain
                                .get(packet.getHash(i))));
                        }
                        else
                        {
                            logger.finer("Request for resource "
                                + packet.getHash(i) + "(" + packet.getType(i)
                                + ")! Could not be found! Sending reply...");
                            connection.send(new PacketNotFound(packet
                                .getType(i), packet.getHash(i)));
                        }
                    }
                }
                return;
            }
            case BALLOT:
            {
                PacketBallot packet = new PacketBallot(data);
                logger.fine("Received Ballot " + packet.getBallot().getRoot()
                    + " with UUID " + packet.getBallot().getID());
                final Ballot b = packet.getBallot();
                new Thread(new Runnable() {
                    @Override
                    public void run()
                    {
                        /*
                         * Check that Ballot was requested and not unsolicited.
                         */

                        if (!dataRequests.remove(b.getRoot()))
                        {
                            logger.fine("Ballot " + b.getID()
                                + " is unsolicited.");
                            return;
                        }

                        /*
                         * Check that Ballot is not too large to be saved
                         * (closing a possible crashing vector).
                         */

                        if (b.getBytes().length >= BlockChain.MAXIMUM_BLOCK_SIZE - 60)
                        {
                            logger.fine("Ballot " + b.getID()
                                + " is too large.");
                            return;
                        }

                        /*
                         * Check that Ballot is not currently in list of this
                         * Node's Ballots (the Ballot pool).
                         */

                        for (int i = 0; ballots.size() > i; i++)
                        {
                            if (ballots.get(i).getID()
                                .equalsIgnoreCase(b.getID()))
                            {
                                logger.fine("Ballot " + b.getID()
                                    + " is a duplicate.");
                                return;
                            }
                        }

                        /*
                         * Check that Ballot is not currently in the BlockChain.
                         */

                        if (blockChain.hasBallot(b.getID()))
                        {
                            logger.fine("Ballot " + b.getID()
                                + " is already in the BlockChain.");
                            return;
                        }

                        /*
                         * Check with Election Authority that the Ballot was
                         * submitted. Validate signature using the public key
                         * stored by the Election Authority.
                         * 
                         * NOTE: This must be changed when an actual Election
                         * Authority database is used.
                         */

                        if (demo)
                        {
                            ECPublicKey publicKey = Submitter.getKey(b.getID());

                            if (publicKey == null)
                            {
                                logger.fine("Ballot " + b.getID()
                                    + " was not cast.");
                                return;
                            }

                            try
                            {
                                Signature dsa =
                                    Signature.getInstance("SHA1withECDSA");
                                byte[] signature =
                                    ByteUtil.hexToBytes(b.getSignature()
                                        .startsWith("0") ? b.getSignature()
                                        .replaceFirst("0+", "") : b
                                        .getSignature());
                                dsa.initVerify(publicKey);
                                dsa.update(ByteUtil.hexToBytes(b
                                    .getSignatureRoot()));

                                if (!dsa.verify(signature))
                                {
                                    logger.fine("Ballot " + b.getID()
                                        + " had invalid signature.");
                                    return;
                                }
                            }
                            catch (Exception e)
                            {
                                logger.log(
                                    Level.WARNING,
                                    "Could not validate signature of Ballot "
                                        + b.getID(),
                                    e);
                                return;
                            }
                        }
                        else
                        {
                            /*
                             * This is where Election Authority checks would go.
                             */
                        }

                        /*
                         * Ballot is valid, add it to the Ballot pool.
                         */

                        ballots.add(b);

                        if (ballots.size() >= BLOCK_THRESHOLD)
                        {
                            generateBlock();
                        }

                        PacketInv inv = new PacketInv();
                        inv.addInv(b);
                        sendToAll(inv);
                    }
                }, "Ballot Validation " + packet.getBallot().getRoot()).start();
                return;
            }
            case BLOCK:
            {
                try
                {
                PacketBlock packet = new PacketBlock(data);
                logger.info("Received block " + packet.getBlock().getHash()
                    + "!");
                final Block b = packet.getBlock();
                new Thread(new Runnable() {
                    @Override
                    public void run()
                    {
                        /*
                         * Check that Block was requested and not unsolicited.
                         */

                        if (!dataRequests.remove(b.getHash()))
                        {
                            logger.info("Block " + b.getHash()
                                + " is unsolicited.");
                            return;
                        }

                        /*
                         * Check that Block is not too large to be saved
                         * (closing a possible crashing vector).
                         */

                        if (b.getBytes().length >= BlockChain.MAXIMUM_BLOCK_SIZE)
                        {
                            logger.info("Block " + b.getHash()
                                + " is too large.");
                            return;
                        }
                        
                        /*
                         * Check that Block is not currently in the BlockChain.
                         */

                        if (blockChain.contains(b.getHash()))
                        {
                            logger.info("Block " + b.getHash()
                                + " is already in the BlockChain.");
                            return;
                        }
                        
                        /*
                         * Check that the Block has a satisfactory and valid
                         * Proof of Work. Also validates the Merkle Root.
                         */
                        
                        if (!b.validate())
                        {
                            logger.info("Block " + b.getHash()
                                + " is invalid.");
                            return;
                        }
                        
                        /*
                         * Check that Block timestamp is within reasonable
                         * bounds. (1 hour ahead of this Node's time and greater
                         * than the mean time of the previous Blocks.)
                         */
                        
                        if (b.getTime() > System.currentTimeMillis() / 60000 + 60
                            || (blockChain.contains(b.getPrevHash()) && b
                                .getTime() < blockChain.getMedianTime(b
                                .getPrevHash())))
                        {
                            logger.info("Block " + b.getHash()
                                + " was mined at an invalid time.");
                            return;
                        }

                        //TODO Check Ballots
                        
                        /*
                         * Block is valid. Stop current Block Generation if the
                         * parents match, and synchronize Ballots.
                         */
                        
                        if (blockGenHash != null && b.getPrevHash().equalsIgnoreCase(blockGenHash))
                        {
                            stopBlockGeneration();
                        }
                        
                        ArrayList<Ballot> bBallots = b.getBallots();
                        for (int i = 0; bBallots.size() > i; i++)
                        {
                            for (int j = 0; ballots.size() > j; j++)
                            {
                                if (ballots.get(j).getID()
                                    .equalsIgnoreCase(bBallots.get(i).getID()))
                                {
                                    ballots.remove(j--);
                                }
                            }
                        }
                        
                        blockChain.append(b);
                        PacketInv inv = new PacketInv();
                        inv.addInv(b);
                        sendToAll(inv);
                        generateBlock();
                    }
                }, "Block Validation " + packet.getBlock().getHash()).start();
                return;
                }
                catch (Exception e)
                {
                    System.out.println(Packet.toString(data));
                }
            }
            case GETBLOCKS:
            {
                PacketGetBlocks packet = new PacketGetBlocks(data);
                BlockChain.Node root = blockChain.getNode(packet.getHash());
                if (root != null)
                {
                    PacketInv inv = new PacketInv();
                    inv.addInv(root.getBlock());
                    ArrayList<Block> blocks = new ArrayList<Block>();
                    BlockChain.Node top =
                        blockChain.getNode(blockChain.getTop().getHash());
                    while (top != root)
                    {
                        blocks.add(top.getBlock());
                        top = top.getParent();
                    }
                    for (int i = 0; blocks.size() > i; i++)
                    {
                        inv.addInv(blocks.get(blocks.size() - 1 - i));
                    }
                    connection.send(inv);
                }
                return;
            }
            default:
                logger.finest("Could not parse invalid packet.");
        }
    }


    // -------------------------------------------------------------------------
    /**
     * Connects this Node to a peer Node via the specified IP Address and port.
     * 
     * @param address
     *            IP Address of the peer Node
     * @param port
     *            Port of the peer Node
     * @return Returns a {@link Connection connection} object if the connection
     *         to the peer was successful. If the connection was unsuccessful,
     *         null is returned.
     */
    public Connection connect(InetAddress address, int port)
    {
        if (ip.equals(address)
            && port == this.port
            || getConnection("/" + address.getHostAddress() + ":" + port) != null)
        {
            logger.finer("Duplicate connection /" + address.getHostAddress()
                + ":" + port + "!");
            return null;
        }

        try
        {
            Connection c = new Connection(this, new Socket(address, port));
            if (c.getSocket().isConnected())
            {
                logger.info("Connected to Node " + c.getHostName()
                    + "! Sending version information...");
                c.setConnectionStatus(Connection.CONNECTION_NODE_ONLY);
                c.connect();
                c.send(new PacketVersion(VERSION, this.port));
                peers.add(c);
                return c;
            }
            else
            {
                logger.log(
                    Level.FINE,
                    "Could not connect to Node " + c.getHostName() + "!");
            }
        }
        catch (Exception e)
        {
            logger.log(Level.FINE, "Node connection error!", e);
        }
        return null;
    }


    // -------------------------------------------------------------------------
    /**
     * Disconnects the specified peer and removes its {@link Connection
     * connection} from the list of this Node's peers.
     * 
     * @see Connection
     * @param c
     *            Connection of the peer to remove
     */
    public void removeConnection(Connection c)
    {
        if (peers.contains(c))
        {
            if (c.isConnected())
            {
                c.disconnect();
            }
            peers.remove(c);
        }
    }


    // -------------------------------------------------------------------------
    /**
     * Returns the {@link Connection connection} with the specified name from
     * the current list of peers of this Node.
     * 
     * @see Connection
     * @see Connection#getHostName()
     * @param hostname
     *            Name of this connection in the format "/ipaddress:port", or
     *            the human readable name of the peer.
     * @return Connection with the corresponding host name specified if one
     *         exists, otherwise returns null.
     */
    public Connection getConnection(String hostname)
    {
        for (int i = 0; peers.size() > i; i++)
        {
            if (peers.get(i).getHostName().equals(hostname)
                || peers.get(i).getName().equals(hostname))
            {
                return peers.get(i);
            }
        }
        return null;
    }


    // -------------------------------------------------------------------------
    /**
     * Sends the specified {@link Packet packet} to all known peers.
     * 
     * @see Packet
     * @see Connection
     * @param p
     *            Packet to send to all known peers.
     */
    public void sendToAll(Packet p)
    {
        for (int i = 0; peers.size() > i; i++)
        {
            peers.get(i).send(p);
        }
    }


    // -------------------------------------------------------------------------
    /**
     * Returns the running status of this Node. (The {@link Node#running
     * running} flag)
     * 
     * @return True if this Node is currently running, False otherwise.
     */
    public boolean isRunning()
    {
        return running;
    }


    // -------------------------------------------------------------------------
    /**
     * Returns a list of this Node's known peers.
     * 
     * @return An ArrayList containing all of this Node's known peers.
     */
    public ArrayList<Connection> getPeers()
    {
        return peers;
    }


    // -------------------------------------------------------------------------
    /**
     * Attempts to generate a new Block from a limited number of known,
     * validated Ballots. If a Block is generated successfully, it is broadcast
     * to all peer Nodes. If the Block cannot be generated before a valid Block
     * with the same parent is received, the {@link Node#blockGen Block
     * Generation Thread} initialized by this method is interrupted and stopped.<br>
     * <br>
     * This method only allows one Block to be generated at any given time, so
     * this method will return if called while a Block is currently being
     * generated. Instead, the {@link Node#stopBlockGeneration() Stop Block
     * Generation} method must be called first, and then this method.
     */
    public void generateBlock()
    {
        if (blockGen != null || ballots.size() == 0 || !running)
        {
            return;
        }
        final ArrayList<Ballot> tempBallot = new ArrayList<Ballot>();
        int size = Math.min(BLOCK_THRESHOLD, ballots.size());
        for (int i = 0; size > i; i++)
        {
            tempBallot.add(ballots.get(i));
        }
        blockGen = new Thread(new Runnable() {
            @Override
            public void run()
            {
                logger.info("Generating Block for " + tempBallot.size() + " Ballots...");
                long time = System.currentTimeMillis();
                blockGenHash = blockChain.getTop().getHash();
                Block b =
                    new Block(blockGenHash, Block.MAXIMUM_TARGET, tempBallot);
                try
                {
                    b.genProof();
                    logger.info("Generated Block in "
                        + ((System.currentTimeMillis() - time) / 1000)
                        + " seconds!\n" + b.toString());
                    for (int i = 0; tempBallot.size() > i; i++)
                    {
                        for (int j = 0; ballots.size() > j; j++)
                        {
                            if (ballots.get(j).getID().equalsIgnoreCase(tempBallot.get(i).getID()))
                            {
                                ballots.remove(j--);
                            }
                        }
                    }
                    logger.info("Adding block to BlockChain...");
                    blockChain.append(b);
                    PacketInv inv = new PacketInv();
                    inv.addInv(b);
                    logger.info("Notifying peers of block...");
                    sendToAll(inv);
                    blockGenHash = null;
                    blockGen = null;
                    generateBlock();
                }
                catch (InterruptedException e)
                {
                    //
                }
            }
        }, "Block Generation " + blockChain.getTop().getHash());
        blockGen.start();
    }


    // -------------------------------------------------------------------------
    /**
     * Stops any current Block generation by this Node. Interrupts the
     * {@link Node#blockGen Block Generation Thread} and resets the
     * {@link Node#blockGenHash Block Generation Hash} variable.
     */
    public void stopBlockGeneration()
    {
        if (blockGen != null)
        {
            blockGen.interrupt();
            blockGen = null;
            if (blockGenHash != null)
            {
                logger.info("Block generation stopped!");
            }
            blockGenHash = null;
        }
    }

    
    // -------------------------------------------------------------------------
    /**
     * Adds a hash to the {@link Node#dataRequests data requests} list.
     * 
     * @param hash
     *            Hash to add to the data requests list
     */
    public void addDataRequest(String hash)
    {
        dataRequests.add(hash);
    }


    // -------------------------------------------------------------------------
    /**
     * Checks if the version of another Node is compatible with the
     * {@link Node#VERSION version} of this Node.
     * 
     * @param v
     *            Version to compare with this Node's version.
     * @return True if the two versions are compatible, False otherwise.
     */
    private static boolean validateVersion(Version v)
    {
        return VERSION.isEqualTo(v);
    }

}
